{% load static %}
<script
  src="{% static 'js/bootstrap.bundle.js' %}"
  type="text/javascript"
  defer
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>
<script
  src="{% static 'js/main.js' %}"
  type="text/javascript"
  defer
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>


<script>
  // Auto-show messages as modals (queued one after another)
  window.addEventListener('load', function () {
    var modalEls = Array.from(document.querySelectorAll('.modal[data-autoshow="true"]'));
    if (!modalEls.length) return;

    // Fallback to alert if Bootstrap not loaded for some reason
    if (typeof bootstrap === 'undefined') {
      alert(modalEls.map(function (el) {
        var body = el.querySelector('.modal-body');
        return body ? body.textContent.trim() : '';
      }).join('\n\n'));
      return;
    }

    function showNext(i) {
      if (i >= modalEls.length) return;
      var el = modalEls[i];
      var m = new bootstrap.Modal(el);
      el.addEventListener('hidden.bs.modal', function () { showNext(i + 1); }, { once: true });
      m.show();
    }
    showNext(0);
  });
</script>

<!-- Search + highlight (guarded, no crashes, preserves original text) -->
<script>
  "use strict";
  document.addEventListener("DOMContentLoaded", () => {
    const searchBox = document.getElementById("searchBox");
    const comboItems = document.querySelectorAll(".combo-item");
    const notFound = document.getElementById("notFound");

    if (!searchBox || comboItems.length === 0) return;

    // Keep original text safe in dataset
    comboItems.forEach((item) => {
      const p = item.querySelector("p");
      if (p && !p.dataset.orig) p.dataset.orig = p.textContent;
    });

    const highlight = (text, query) => {
      // escape regex special chars from query
      const esc = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const re = new RegExp(`(${esc})`, "ig");
      return text.replace(re, `<span class="highlight">$1</span>`);
    };

    searchBox.addEventListener("input", function () {
      const q = this.value.trim().toLowerCase();
      let any = false;

      comboItems.forEach((item) => {
        const p = item.querySelector("p");
        if (!p) return;
        const orig = p.dataset.orig || p.textContent;
        const hay = orig.toLowerCase();

        if (!q) {
          p.innerHTML = orig;
          item.style.display = "";
          any = true;
          return;
        }

        if (hay.includes(q)) {
          p.innerHTML = highlight(orig, q);
          item.style.display = "";
          any = true;
        } else {
          p.innerHTML = orig;
          item.style.display = "none";
        }
      });

      if (notFound) notFound.style.display = any ? "none" : "block";
    });
  });
</script>

<!-- Active section marker using IntersectionObserver (smooth + efficient) -->
<script type="text/javascript">
  "use strict";
  document.addEventListener("DOMContentLoaded", () => {
    const sections = document.querySelectorAll("main section[id]");
    const navLinks = document.querySelectorAll(".sidebar .nav-link");
    if (sections.length === 0 || navLinks.length === 0) return;

    const map = new Map();
    navLinks.forEach((link) => {
      const href = link.getAttribute("href") || "";
      if (href.startsWith("#")) map.set(href.slice(1), link);
    });

    const onIntersect = (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const id = entry.target.id;
          navLinks.forEach((l) => l.classList.remove("active"));
          const active = map.get(id);
          if (active) active.classList.add("active");
        }
      });
    };

    const io = new IntersectionObserver(onIntersect, {
      root: null,
      rootMargin: "0px 0px -60% 0px", // trigger when top third enters
      threshold: 0.25,
    });

    sections.forEach((sec) => io.observe(sec));
  });
</script>

<!-- Chart.js (only if canvases exist; no console errors) -->
<script type="text/javascript">
  "use strict";
  document.addEventListener("DOMContentLoaded", () => {
    if (typeof Chart === "undefined") return;

    const membershipCanvas = document.getElementById("membershipChart");
    if (membershipCanvas) {
      const ctx = membershipCanvas.getContext("2d");
      new Chart(ctx, {
        type: "line",
        data: {
          labels: ["Jan", "Feb", "Mar", "Apr", "May", "Jun"],
          datasets: [
            {
              label: "Members",
              data: [120, 150, 180, 220, 260, 300],
              backgroundColor: "rgba(13,110,253,0.2)",
              borderColor: "rgba(13,110,253,1)",
              borderWidth: 2,
              tension: 0.3,
              fill: true,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          animation: { duration: 300 },
        },
      });
    }

    const revenueCanvas = document.getElementById("revenueChart");
    if (revenueCanvas) {
      const ctx = revenueCanvas.getContext("2d");
      new Chart(ctx, {
        type: "bar",
        data: {
          labels: ["Week 1", "Week 2", "Week 3", "Week 4"],
          datasets: [
            {
              label: "Revenue ₹",
              data: [3000, 4500, 7000, 5000],
              backgroundColor: "rgba(255,193,7,0.7)",
              borderColor: "rgba(255,193,7,1)",
              borderWidth: 1,
              borderRadius: 5,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: { legend: { display: false } },
          scales: { y: { beginAtZero: true } },
          animation: { duration: 300 },
        },
      });
    }
  });
</script>

<!-- Razorpay flow (guards + graceful errors) -->
<script>
  "use strict";
  document.addEventListener("DOMContentLoaded", () => {
    const form = document.getElementById("payForm");
    if (!form) return;

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      try {
        const resp = await fetch(form.action, {
          method: "POST",
          headers: { "X-Requested-With": "XMLHttpRequest" },
          body: new FormData(form),
        });

        if (!resp.ok) throw new Error("Failed to create order");
        const data = await resp.json();

        if (typeof Razorpay === "undefined") {
          alert(
            "Payment library not loaded. Please check your network and try again."
          );
          return;
        }

        const options = {
          key: data.razorpay_key_id,
          amount: data.amount,
          currency: data.currency,
          name: "Membership",
          description: "Monthly membership (30 days)",
          order_id: data.order_id,
          handler: async function (response) {
            try {
              const fd = new FormData();
              fd.append("razorpay_order_id", response.razorpay_order_id);
              fd.append("razorpay_payment_id", response.razorpay_payment_id);
              fd.append("razorpay_signature", response.razorpay_signature);
              fd.append("csrfmiddlewaretoken", "{{ csrf_token }}");
              const v = await fetch("{% url 'member:verify' %}", {
                method: "POST",
                body: fd,
              });
              if (!v.ok) throw new Error("Verification failed");
              alert("Payment successful. Reloading…");
              location.reload();
            } catch (err) {
              console.error(err);
              alert(
                "Payment captured, but verification failed. Contact support."
              );
            }
          },
          prefill: {
            email: "{{ request.user.email|default:'' }}",
            name: "{{ request.user.get_full_name|default:request.user.username }}",
          },
          theme: { color: "#0a66c2" },
        };

        const rzp = new Razorpay(options);
        rzp.open();
      } catch (err) {
        console.error(err);
        alert("Unable to start payment right now. Please try again later.");
      }
    });
  });
</script>
